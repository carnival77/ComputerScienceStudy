### 메모리란? [https://www.youtube.com/embed/dgMeWRy84l8](https://www.youtube.com/embed/dgMeWRy84l8)

- 메모리란 프로그램과 프로그램 수행에 필요한 데이터 및 코드를 저장하는 장치이다.
- 메모리는 크게 내부 기억장치인 **주기억장치**(DRAM,register,cache memory)와 외부 기억장치인 **보조 기억장치**(SSD,HDD)로 분류된다.

### 가상 메모리 등장 배경

초창기 컴퓨터에는 가장 큰 실행 애플리케이션의 주소 공간보다 큰 RAM의 용량을 보유해야 했다. 그렇지 않으면 **메모리 부족**으로 해당 애플리케이션을 실행할 수 없었다.

이후 컴퓨터에서는 프로그래머가 애플리케이션의 일부부만 기억장치에 올려 실행하도록 지정할 수 있게하는 **오버레이 기법**을 사용해 메모리 부족 문제를 해결하고자 했다.

→시스템 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우 똑같은 메모리 부족 오류 발생

**가상 메모리 기법**은 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 **최소한 얼마만큼의 메모리가 필요한지**에 집중하여 문제를 해결하고자 하였다.

→메모리 접근은 순차적이고 지역화 되어 있다. 애플리케이션의 일부분만 메모리(기억장치)에 올려진다면 메모리에 올라가지 않는 나머지는 보조 기억장치에 위치한다. : **가상 메모리의 핵심은 보조 기억장치**이다.

### 가상 메모리

가상 메모리는 메모리가 실제 메모리보다 많아 보이게 하는 기술로, 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다는 점에 착안하여 고안되었음.

> [https://ahnanne.tistory.com/15](https://ahnanne.tistory.com/15) (출처)
> 
- 애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가며 애플리케이션의 나머지는 디스크에 남게 됨. 즉, 디스크가 RAM의 보조 기억장치(backing store)처럼 작동하는 것임.
    - 결국 빠르고 작은 기억장치(RAM)을 크고 느린 기억장치(디스크)와 병합하여, 하나의 크고 빠른 기억장치(가상 메모리)처럼 동작하게 하는 것임.
- 가상 메모리를 구현하기 위해서는 컴퓨터가 특수 메모리 관리 하드웨어를 갖추고 있어야만 함. ⇒ 바로 **[MMU(Memory Management Unit)](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC_%EC%9E%A5%EC%B9%98)**!
    
    예전에는 MMU가 이와 같이 따로 분리된 하드웨어였지만 최근의 아키텍처에서는 프로세서와 같은 칩에 회로로 삽입된다. (출처: 위키백과)
    
    ![https://blog.kakaocdn.net/dn/bMHw35/btq5gwPeRPj/qZQ20xnWN3mIFoKPHDazh0/img.jpg](https://blog.kakaocdn.net/dn/bMHw35/btq5gwPeRPj/qZQ20xnWN3mIFoKPHDazh0/img.jpg)
    
    - MMU는 하고, 하는 기능을 수행함.
        
        가상주소를 물리주소로 변환
        
        메모리를 보호
        
    - MMU를 사용하게 되면, CPU가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업이 수행됨.
    - 그러나 메모리를 일일이 가상 주소에서 물리적 주소로 번역하게 되면 작업 부하가 너무 높아지므로, MMU는 RAM을 여러 부분(페이지, pages)로 나누어 각 페이지를 하나의 독립된 항목으로 처리함.
    - 페이지 및 주소 번역 정보를 기억하는 작업이 가상 메모리를 구현하는 데 있어 결정적인 절차임.
    
- 가상 메모리의 핵심은 필요한 부분만 메모리에 적재(**부분적재**)하는 것이다.
    
    → 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올린다 (적재 여부를 *페이지테이블*에 표시)
    
    실행될 가능성이 낮은 코드 (ex) 오류 처리 코드 등), 과도하게 크게 선언된 데이터 영역(ex) 행렬, 리스트 및 테이블은 실재로 필요한 크기 이상으로 프로그램에서 선언되어 할당됨), 프로그램의 옵션 부분을 처리하느 코드 등은 굳이 메모리에 적재될 필요가 없다!
    
    ⇒ Locality of Reference 성질: 프로그램의 어느 한 특정 작은 부분만 한동안 집중적으로 참조하는 현상 (Principle of Locality)
    
    ⇒ 한정된 크기의 실제 메모리를 효율적으로 사용하는 방법 필요
    
    → 프로세스의 일부분은 페이지 단위 또는 세그먼트 단위지만 현재는 대부분 **페이지 단위** 사용 (세그먼트 기법 & 페이지 기법)
    
- 현재 필요한 페이지만 메모리에 올리는 것을 **요구페이징**이라고 한다.
    
    ![스크린샷 2021-11-21 오후 6.59.01.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56ab8aa2-e1c8-4869-a537-056cc93c8af4/스크린샷_2021-11-21_오후_6.59.01.png)
    

⇒ 페이징과 스와핑을 합쳐놓은 형태라고 생각하면 쉽다. 메모리를 페이지 단위로 나누어 **페이지 테이블**을 통해 물리 메모리에 맵핑을 하는데, 필요한 페이지만을 스와핑을 통해 메모리에 올리고 나머지는 하드디스크에 두는 방식이다.

- 🤓 page table: A는 4번에 있고, C는 6번에 있고, F는 9번에있어~
    
    → valid-invalid bit로 알 수 있음.
    
- 유효/무효 비트(Valid-invalid bit)란? 현재 메모리에 페이지가 있는지 없는지를 나타내는 비트 (있다면 1, 없다면 0)
- 오염비트(dirty bit, modify bit): 페이지 대치 시 디스크로 다시 출력 (write back) 필요 여부 판정 필요, 페이지 적재 후 변경 유무를 표시

# 요구페이징(Demand Paging)

(페이징 기법: 컴퓨터가 메인 메모리에서 사용하기 위해 2차 기억 장치(보조 기억 장치)로부터 데이터를 저장하고 검색하는 메모리 관리 기법이다)

- CPU가 해당 페이지를 요구할 때까지 그 페이지를 메모리에 올리지 않는 방식 (즉, 한번도 접근되지 않는 페이지는 물리 메모리에 전혀 적재되지 않는다)
- 페이지 부재(page fault)가 발생하면 그 때 트랩을 걸어 해당 페이지를 적재
    
    ![스크린샷 2021-11-21 오후 7.00.04.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d0966d5f-edd7-47d0-87e7-b59d15462d99/스크린샷_2021-11-21_오후_7.00.04.png)
    
    ### [페이지 부재를 처리하는 과정]
    
    1) 특정 페이지를 실행하기 위해 페이지 테이블을 참조하여 메모리가 올라와있는지 여부를 확인 (valid-invalid bit 확인)
    
    2) 페이지가 메모리에 올라와 있지 않은 경우 (page fault, invalid인 경우) MMU가 인터럽트를 발생시킴 
    
    - MMU(Memory Management Unit): CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품으로 가상 메모리와 실제 메모리 사이에서 주소 변환 역할을 한다. (논리 메모리 주소 → 물리 메모리 주소로 변환)
    
    3, 4) 운영체제는 해당 프로세스를 wait 상태로 만들고 요구된 페이지를 하드디스크에서 찾아 메모리의 자유프레임(free frame)(빈공간)에 적재
    
    - 프레임 vs 페이지?
    
    5) 페이지 테이블 갱신 (i → v)
    
    6) 트랩에 의해 중단되었던 명령을 다시 수행: wait상태인 해당 프로세스를 다시 ready → running 하여 작업 재진행
    
    가상 메모리를 만드는 방법은 대표적으로 두 가지(요구 페이징, 요구 세그먼트)가 존재하지만, 대부분 **요구 페이징을 사용**하므로 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다.
    
    ## 프로그램 부분 적재의 이점
    
    - 프로그램의 크기가 물리적인 용량에 무관
    - 더 많은 프로그램이 메모리를 공유하여 CPU 사용률과 처리율(Throughput)을 향상함
    - 주소 결속을 실행 시간에 할 수 있음
    - 결국, 페이지 부재율(page-fault rate)을 낮추어 성능을 높이는 것이 문제!
    
    ---
    
    그럼 물리 메모리가 다 차면??
    
    # 페이지 대치(교체)
    
    - 물리 메모리에 여유가 없을 때 희생될 페이지를 찾아 대치
    
    ![https://media.vlpt.us/images/syoung125/post/86531d5a-a75d-451d-8a5c-c22ef2ce7387/image.png](https://media.vlpt.us/images/syoung125/post/86531d5a-a75d-451d-8a5c-c22ef2ce7387/image.png)
    
    - 페이지 부재율(page fault) 최소화하기 위해서는 페이지 교체를 '잘' 해야한다!
    
    ## 페이지 대치 알고리즘
    
    1. 최적 대치 알고리즘
    2. FIFO
    3. LRU
    4. LRU 근사 알고리즘
        - Additional Reference Bit 알고리즘
        - Second Chance 알고리즘
        - LFU(Least Frequently Used)
        - MFU(Most Frequently Used)
