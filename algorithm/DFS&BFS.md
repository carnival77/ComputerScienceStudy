
<div align="center">
  <br />
  <h1>DFS & BFS </h1>
  <br />
</div>

## 목차

1. [**그래프**](#1)
2. [**DFS**](#2)
3. [**BFS**](#3)

<br />

<div id="1"></div>

## 그래프

### 그래프 용어
<div>
  <img width="850" alt="스크린샷 2021-12-21 오후 2 34 23" src="https://user-images.githubusercontent.com/54795404/146877104-9ce6b9f9-8994-4474-90cc-fef51963bf24.png">
</div>

***정점(vertex)***
노드(node)라고도 하며 데이터가 저장되는 그래프의 기본 원소이다.
(위 그래프에서 A,B,C,D)

***간선(edge)***
링크(link)라고도 하며 정점 간의 관계를 나타낸다.

***인접 정점(adjacent vertex)***
하나의 정점에서 간선에 의해 직접 연결되어 있는 정점을 뜻한다.
(위 그래프에서 A의 인접정점은 C,B,D이다.)

***차수(degree)***
정점에 연결된 간선의 수를 말한다.
위 그래프에서 정점 A의 차수는 3이고, 모든 정점의 차수를 합하면 8이다.(A-3,B-1,C-2,D-2)
***진입 차수(in-degree)***  : 방향 그래프의 경우 외부에서 오는 간선의 수
***진출 차수(out-degree)*** : 방향 그래프의 경우 외부로 향하는 간선의 수 

***경로(path)***
간선을 따라갈 수 있는 길을 말하며, 정점을 나열하여 표시한다. 

***경로의 길이(length)***
경로를 구성하는 데 사용된 간선의 수를 뜻한다.

***단순경로(simple path)***
경로 중에서 반복되는 간선이 없는 경로이다.

***사이클(cycle)***
시작 정점과 종료 정점이 같은 단순 경로를 뜻한다.
(위 그래프에서 A-D-C-A)

## 그래프의 구현 방법
컴퓨터에서 그래프를 구현하는 방법에는 인접행렬(Array)을 사용하는 방법과 인접리스트(Linked List)를 사용하는 방법이 있다.

## 인접행렬(Adjacency Materix)
- 인접행렬 방식
  인접행렬은 그래프의 노드를 2차원 배열로 만든 것이다.
  노드들 간에 직접 연결되어 있으면 1을, 아니면 0을 넣어서 행렬을 완성시킨다.
  
- 인접행렬의 장점
  2차원 배열 안에 모든 정점들의 간선 정보가 담겨 있기 때문에 두 정점에 대한 연결 정보를 조회할 때 ***O(1)*** 의 시간 복잡도면 가능하다.
  인접리스트에 비해 구현이 쉽다.
  
- 인접행렬의 단점
  모든 정점에 대해 간선 정보를 대입해야 하므로 ***O(n^2)*** 의 시간 복잡도가 소요된다.
  무조건 2차원 배열이 필요하기 때문에 필요 이상의 공간이 낭비된다.
  <div>
    <img width="850" alt="스크린샷 2021-12-21 오후 3 25 21" src="https://user-images.githubusercontent.com/54795404/146882214-932850ad-8bac-438d-8957-817aca7911ed.png">
  </div>
  
## 인접리스트(Adjacency List)
- 인접리스트 방식
  인접리스트 그래프의 노드를 리스트로 표현한 것이다.
  주로 정점의 리스트 배열을 만들어 관계를 설정하며 노드들 간에 직접 연결이 되어있으면 해당 노드의 인덱스에 그 노드를 삽입해주면 된다.
  <div>
    <img width="654" alt="스크린샷 2021-12-21 오후 3 33 50" src="https://user-images.githubusercontent.com/54795404/146883214-98cc633c-69e2-45d6-9e1b-2b7b78fd20c3.png">
  </div>

- 인접리스트의 장점
  정점들의 연결 정보를 탐색할 때 ***O(n)*** 시간이면 가능하다.
  필요한 만큼의 공간만 사용하기 때문에 공간의 낭비가 적다.
  
- 인점리스트의 단점
  특정 두 점이 연결되었는지 확인하려면 인접행렬에 비해 시간이 오래걸린다.O(E) : E는 간선의 개수
  구현이 비교적 어렵다.
  
<div>
  
</div>
<br />

<div id="2"></div>

## DFS(Depth-First-Search)
1.모든 노드를 방문하고자 하는 경우에 이 방법을 선택함
2.깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단함
3.검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느림

<br />

<div id="3"></div>

## BFS(Breadth-First Search)
루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법으로,
시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법입니다.
|----|----|
|DFS(깊이우선탐색)	|BFS(너비우선탐색)|
|현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색	|현재 정점에 연결된 가까운 점들부터 탐색|
|스택 또는 재귀함수로 구현	|큐를 이용해서 구현|

### DFS vs BFS
1. 그래프의 모든 정점을 방문해야하는 문제 (DFS/BFS 둘다 상관 없음)
2. 경로의 특징을 저장해둬야 하는 문제
예를 들면 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 ***DFS***를 사용합니다. (BFS는 경로의 특징을 가지지 못합니다)
3. 최단거리 구해야 하는 문제
미로 찾기 등 최단거리를 구해야 할 경우, ***BFS***가 유리합니다.
왜냐하면 깊이 우선 탐색으로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만,
너비 우선 탐색으로 현재 노드에서 가까운 곳부터 찾기 때문에경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문입니다.


