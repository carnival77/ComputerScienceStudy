# SSL

```
SSL(Secure Sockets Layer)는 데이터를 암호화하거나 통신 상대를 인증함으로써 웹사이트와 브라우저 사이에 전송된 데이터를 보호하는 인터넷 암호화 통신 프로토콜입니다. 보통 HTTP 통신을 할 때, ‘https://’로 시작하는 URL들이 대표적인 예시이며 HTTPS(HTTP over SSL)는 HTTP를 SSL로 암호화한 프로토콜입니다.
```
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99B157445BC96AA31DD328)


SSL은 표현계층의 프로토콜로 응용 계층 아래에 있기 때문에, 어떤 응용 계층의 데이터라도 암호화해서 보낼 수 있다.

HTTP는 기본적으로 평문 데이터 전송을 원칙으로 하기 때문에 개인의 프라이버시가 오가는 서비스들(전자상거래, 전자메일, 사내문서)에 사용하기 힘들다.

따라서 HTTPS를 이용하게 되고 HTTPS는 SSL 레이어위에 HTTP를 통과 시키게 된다.

즉 평문의 HTTP 문서는 SSL 레이어를 통과하면서 암호화 돼서 목적지에 도착하고,

목적지에서는 SSL 레이어를 통과하면서 복호화 돼서 웹 브라우저에 전달된다.

  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F999BB7415BC96F2A1864D8)

**SSL 프로토콜은 OSI 7계층 모델의 어느 한 계층에 속해서 동작하는 것이 아니라**,

응용계층과 전송계층 사이에 독립적인 프로토콜 계층을 만들어서 동작하며,

이 때, 응용계층의 프로토콜들은 외부로 보내는 데이터를 TCP가 아닌 SSL에 보내게 되고, SSL은 받은 데이터를 암호화하여 TCP에 보내어 외부 인터넷으로 전달하게 된다.

전달 받을 때 역시, TCP로부터 받은 데이터를 복호화하여 응용계층에 전달하게 되는데, 이 과정에서 Application은 SSL을 TCP로 인식하고, TCP는 SSL을 Application으로 인식하기 때문에, Application과 TCP사이의 데이터 전달 방식은 기존 전달 방식을 그대로 사용하게 된다.


## 암호화 방식

#### SSL 은 대칭키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호시스템을 사용합니다.

### 대칭키 암호화 방식

**대칭키 암호화 방식**은 암호화와 복호화에 **같은 암호키**(대칭키)를 사용하는 암호화 알고리즘이다.

- 장점 : 공개키 암호화 방식에 비해 암호화 및 복호화가 빠르다.
- 단점 : 대칭키를 직접 전달하지 않는 한 **대칭키를 전달하는 과정에서 해킹의 위험에 노출** 될 수 있다.

### 공개키 암호화 방식

**공개키 암호화 방식**은 암호화와 복호화에 사용되는  **암호키를 분리**한 방식이다.
**한 쌍의 키로 암호화, 복호화를 하는 방식으로** **RSA 알고리즘** 이라고 한다.

자신이 가지고 있는 고유한 개인키(Private Key)로만 복호화 할 수 있는 공개키(Public Key)를 대중에 공개한다.
이 방식이 진행되는 방식을 살펴보면, A가 웹상에 공개된 'B의 공개키'를 이용하여 평문을 암호화 하여 전송한다.
B는 자신의 개인키로 복호화한 평문을 확인하고, A의 공개키로 응답을 암호화하여 A에게 보낸다. 그러면 A는 자신의 개인키로 암호화된 응답문을 복호화 하여 확인한다.

- 장점 : 각자의 로컬에 저장된 비밀키가 해킹당하지 않는 한 **대칭키의 단점을 해결**한다.
- 단점 : 암복호화가 매우 복잡하여 **CPU 리소스를 크게 소모한다**

### 개인키 암호화 방식과 공개키 암호화 방식의 혼합 (SSL 핸드쉐이크(SSL Handshake))

그래서 이 두 가지 암호화 방식을 혼합하여 만든 암호화 방식이 SSL의 큰 틀이다.

> 1. A가  **B의 공개키**로 암호화 통신에 사용할  **대칭키**를 암호화 하여 B에게 보낸다.  
> 2. B는 암호문을 받아, 자신의  **개인키**로 복호화 한다.  
> 3. B는  **A로 부터 받은 대칭키**로 A에게 보낼 내용을 암호화 하여 보낸다.  
> 4. A는 자신의  **대칭키**로 암호문을 복호화 한다.  
> 5. 계속해서 대칭키로 통신한다.

즉,**먼저 개인키를 공개키 암호화 방식으로 교환한 다음부터의 통신에서 클라이언트와 서버가 주고 받는 실제 정보는 개인키 암호화/복호화 방식을 사용하는 방식**을 사용한다. 

SSL(Secure Socket Layer)는 넷스케이프사에서 전자상거래보안을 위해 개발한 암호화 방식이다.

## SSL의 작동 방식

> 1. 사이트(서버)는  **인증기관(CA)**에  **자신의 정보와 공개키**를 제출한다.  
> 2. 인증기관(CA)은 정보를 면밀히 검토한 후, 사이트(서버)의 정보와 공개키를 자신의  **개인키**로 암호화 한다.  
> 3. 인증기관(CA)은  **인증기관의 개인키**로 암호화한  **인증서(사이트(서버)의 정보와 공개키)**를 사이트에 송신한다.  
> 4. 개인이 브라우저(클라이언트)를 통해 사이트(서버)에 접속하면,  **인증서(암호화된 사이트의 정보와 공개키)**를 수신한다.  
> 5. 브라우저(클라이언트)는  **인증기관의 공개키**(이 공개키는 브라우저에게만 제공된다)로 복호화 하여  **사이트의 공개키**를 얻는다.  
> 6. 브라우저(클라이언트)가 자신의 **대칭키**를  **사이트의 공개키**로 암호화 하여 사이트에게 보낸다.  
> 7. 사이트(서버)는 자신의  **개인키**로 암호화된  **대칭키**를 복호화한다. 
> 4~7번의 작업을 ‘SSL 핸드쉐이크(SSL Handshake)’라고 합니다.
> 8. 이제 브라우저(클라이언트)와 사이트(서버)는  **대칭키**로 통신한다.

## SSL 인증서의 서비스 보증 과정

### 1. SSL 디지털 인증서

SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 이것은 **클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할**을 한다. 

SSL 인증서에는 다음과 같은 정보가 포함되어 있다.

1.  서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)
2.  서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)

인증서의 내용은 위와 같이 크게 2가지로 구분할 수 있다. 1번은 **클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지**에 대한 내용을 담고 있고, 2번은 **서버와 통신을 할 때 사용할 공개키와 그 공개키의 암호화 방법들의 정보**를 담고 있다.

위와 같은 내용은 CA에 의해서 암호화 된다.
이 때 사용하는 암호화 기법이 [공개키](https://opentutorials.org/course/228/4894#public) 방식이다. CA는 자신의 CA 비공개키를 이용해서 서버가 제출한 인증서를 암호화하는 것이다.

**이후 클라이언트가 해당 CA의 공개키를 이용해서 서버로부터 받은 인증서를 복호화하는 과정에서, 인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화 된 것을 의미**한다.
이렇듯 암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화 되었다는 것을 의미하기 때문이다.
**즉, 공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다. 이러한 것을 전자 서명이라고 부른다.**

SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같다.

-   통신 내용이 공격자에게 노출되는 것을 막을 수 있다.
-   클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.
-   통신 내용의 악의적인 변경을 방지할 수 있다.

클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다. 

## **CA (Certificate Authority)**

디지털 인증서를 제공하는 공인된 기업
**CA는 자체적으로  공개키와  비밀키를 가지고 있습니다**.

### CA를 브라우저는 알고 있다
CA의 리스트와 함께 각 [CA의 공개키](https://opentutorials.org/course/228/4894#public)를 브라우저는 이미 알고 있다.
브라우저가 미리 파악하고 있는 CA의 리스트에 포함되어야만 공인된 CA가 될 수 있는 것이다.



### 2. 서버가 CA로부터 디지털 인증서를 발급받는다 ( 과정 중 1~3 )

SSL은 디지털 증명서를 이용해서 해당 서버가 신뢰할 수 있는 서버인지 아닌지 확인합니다. 따라서, 서버는 CA로부터 디지털 증명서를 발급 받아 설치하는 작업이 필요합니다.

증명서를 설치하는 절차는 다음과 같습니다.

1. 서버 관리자는 비밀키와 공개키를 생성한 후 **공개키와 사이트 정보(도메인)**을 CSR(Certificate Signing Request)이라는 **증명서 서명 요청** 형태로, 제 3의 기관인 CA(Certification authority)에 제출합니다. 이때, **공개키는 제출하고, 비밀키는 별도로 보관합니다.**

 2. CA에서는 검증한 다음 **발급 받고자 하는 서버의  공개 키를 해시(SHA-256 등)**한다.  이렇게 해시한 값을 **Finger Print(지문)**  이라고 합니다. 이제 이 지문을 **CA의 비밀키로 암호화** 하고, 인증서의 발급자 서명으로 등록합니다. 이렇게 서명하는 것을 **디지털** **서명 (Digital Signing)** 이라고 하며, CSR에 삽입됩니다. 그 이후 이 서명된 ‘디지털 증명서’를 서버 관리자에게 발행합니다.
 
 ```
 이러한 방식처럼,

상위 인증 기관이 하위 인증서가 포함하고 있는 공개키 (인증서)를 상위 기관의 비밀키로 암호화  하여

상호 보증하게 되는 것을 인증서 체인(Certificate Chain)  이라고 합니다.
```

 3. 서버 관리자는 디지털 증명서를 서버에 설치합니다.
서버에 디지털 증명서를 설치하고 나면, 이제 SSL 서버로 동작을 할 수 있습니다.

### 3. SSL 인증서가 서버를 보증(SSL 핸드쉐이크(SSL Handshake) 과정)
#### 데이터를 주고 받기 바로 전, 클라이언트가 접속한 서버의 무결성을 확인하여 신뢰 할 수 있는 서버임을 확인하고 대칭키를 전달하는 과정

1. **서버는 브라우저(클라이언트)가 접속하면, 클라이언트에게 공개키와 디지털 증명서를 전송**합니다.
2. 브라우저는 **인증서를 발급한 CA가 자신이 갖고있는 CA 리스트에 있는지 확인**한다.
3. 리스트에 있다면 **해당 CA의 공개키를 이용해서 서버 인증서의 서명(Digital Signing)을 복호화**한다.
**여기서 인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화 된 것을 의미한다. 즉 데이터를 제공한 서버의 신원을 보장해주게 되는 것이다.**
또한 **디지털 서명을 CA 기관의 공개키로 복호화 하여 나온 해시 값**과, **공개키를 해시한 값(지문)**이 일치 한다면,  **인증서가 위조되지 않았음을 인증**하는 것이다.
클라이언트는 이제 서버가 CA 인증기관에서 인증받은 신뢰할 수 있는 서버임을 알았습니다.
또한, 인증서 안에 들어 있는 서버의 공개키도 알았습니다.
이제 **SSL 암호화 방식**을 통해 서로 통신을 주고받기 위해 클라이언트는 자신이 사용할 '대칭키'를 서버에게 전달해 줘야 합니다.
5. **클라이언트는 서버의 공개키로 대칭키를 암호화 하여 서버에게 보내**고,
**서버는 자신의 비밀키로 이를 복호화 하여 클라이언트의 대칭키를 알아내는 것**입니다.

그럼 이제 둘은 사이좋게 대칭키로 암,복호화 하여 통신을 하는 것입니다.

### SSL 핸드쉐이크(SSL Handshake)의 구체적인 과정

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F990B63335BC96D30206CBE)
### 1. 악수 (handshake)

1. **Client Hello** : 클라이언트가 서버에 접속한다.
	-   클라이언트에서 생성한 난수  : 나중에 대칭키를 만들 때 사용할 것
	-   클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.
	-   세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서  [기존의 세션](https://opentutorials.org/course/228/4894#session)을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.


#### 세션 아이디란? 

TLS 통신에서 Handshake를 하는 과정은 당연히 시간이 소요되는 작업입니다.
이 작업을 매번 연결 할 때마다 하려면 시간적으로 너무 비효율적이니,
최초 한번의 Handshake만 Full Handshake를 하기로 하자! 해서 사용하는 것이 Session ID  입니다.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvtDjP%2FbtqGc9RBd7J%2Fd3xo4MlQGNeqzy7HveWYXk%2Fimg.png)
최초 Handshake에선 Session ID가 0으로 없고, 이후 이어지는 Server Hello 메세지를 통해 서버는 Session ID를 보내줍니다. 그러면 클라이언트는 이 Session ID를 로컬에 저장해 둡니다.
이제 다시 이 서버와 Handshake를 맺을 땐, 이 이전에 로컬에 저장해 뒀던 Session ID를 보내면
서버에선 이 Session ID를 다시 사용해도 좋다! 하면 ServerHello에 같은 Session ID를 보내줍니다.
그렇게 되면,  **서버의 인증서를 확인하고 암호화 방법을 선정하고 대칭키를 교환하는 등의 작업을 하지 않습니다.**

2. **Server Hello** : 서버의 Client Hello에 대한 응답
	-   서버에서 생성한 난수  : 클라이언트와 동일하게 대칭키를 만들 때 사용
	-   서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.
	-   인증서
	- **Session ID** : Client Hello에  Session ID가 0으로 왔다면 새로 Session ID를 생성해 보낼 것이고, 만약  Session ID가 0이 아니라면, 그 Session ID가 유효한지 확인

3. **Server Certificate (Server)**
	- **클라이언트는** 서버의 인증서가 무결한지 검증
		- 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.

4. 이전에 주고 받았던  클라이언트의 난수와 서버의 난수를 조합하여 **pre master secret**  이라는 대칭키를 생성. 
	- **공개키 방식**으로 이 **pre master secret** 값을 서버에게 전달한다.
		- 이제 이 **pre master secret(대칭키)를 서버로부터 받은 인증서 안에 들어있는 서버의 공개키로 암호화한 후 서버로 전송**  합니다.

5. **서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화**한다. 
	- 이로서 **서버와 클라이언트가 모두 pre master secret 값을 공유**하게 되었다. 
	
6. **서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다.** 
	- **master secret는 session key를 생성**하는데 이 **session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다.** 
	- 이렇게 해서 **세션키를 클라이언트와 서버가 모두 공유**하게 되었다는 점을 기억하자.
  
7. **Finished**
	- 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

### 2. 세션

세션은 **실제로 서버와 클라이언트가 데이터를 주고 받는 단계**이다. 
이 단계에서 핵심은 **정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다**는 점이다.
암호화된 정보는 상대방에게 전송될 것이고, **상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.**

### 3. 세션 종료

**데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.** 이 때 **통신에서 사용한 대칭키인 세션키를 폐기**한다.
  

## SSL의 장점

SSL은 데이터 보호를 위해 다음과 같은 기능들을 제공합니다.

  
1. 암호화
	: 전송하는 데이터를 암호화해서 중간에 누군가가 패킷을 가로채더라도 그 안의 내용을 해석하지 못하도록 하는 기능입니다.

2. 메시지 다이제스트(Message Digest)
	: 메시지(데이터)의 해시값(다이제스트 값)을 계산하여 데이터와 함께 전송하는 방법입니다. 중간에 누군가가 패킷을 변조하더라도 다이제스트 값을 확인하면 데이터의 변조 사실을 확인할 수 있습니다. 데이터의 무결성을 보장해주는 방법입니다.

3. 디지털 증명서
	: 디지털 증명서는 서버가 신뢰할 수 있는 서버인지 증명하는 파일입니다. 중간에 누군가가 접속 경로를 바꾸어 가짜 서버에 접속했을 때 확인할 수 있도록 하는 기능입니다.


### 대표적인 SSL 서버 프로그램

SSL 서비스를 제공하는 대표적인 서버 프로그램으로는 오픈 소스인 ‘OpenSSL’이나 Windows에 내장되어 있는 ‘IIS’가 있습니다. OpenSL은 주로 Apache 웹 서버와 연계해서 사용합니다.
  

## Reference 

https://snowdeer.github.io/common-sense/2018/02/05/about-ssl/
https://wayhome25.github.io/cs/2018/03/11/ssl-https/
https://doromi.tistory.com/24
https://babbab2.tistory.com/4?category=960153
https://www.crocus.co.kr/1387