> **프로세스 :** 운영체제로부터 자원을 할당받은 작업의 단위.
> 

> **스레드 :** 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e857411-659c-4be2-b064-7a0130f45d03/Untitled.png)

### **프로세스(Process)**

- 디스크로부터 메모리에 적재되어 CPU에 의해 처리되는 실행중인 프로그램이다.
- 운영체제로부터 자원을 할당받으며 이것들을 총칭하여 프로세스라고 한다.
- 각각 독립된 메모리 영역을 갖기 때문에 프로세스는 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4253ccc8-3075-4094-aade-28ea6bed8d48/Untitled.png)

- 메모리 역역
    
    **코드(Code) 영역:**
    
    실행할 프로그램의 코드 및 매크로 상수가 기계어 형태로 저장되는 영역이다. CPU는 코드영역에 저장된 명령어를 하나씩 처리한다.
    
    **데이터(Data) 영역:**
    
    데이터 영역은 코드에서 선언한 전역 변수와 정적(static) 변수가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되어 종료될 때 소멸된다.
    
    **스택(Stack) 영역:**
    
    스택 영역은 함수 안에서 선언된 지역변수, 매개변수, 리턴값, 등이 저장되고 함수 호출시 기록하고 종료되면 제거한다.
    
    스택이라는 자료구조 명칭에서도 알 수 있듯이 후위선출(LIFO) 메커니즘을 따른다.
    
    흔히 재귀함수를 통해 너무 많은 함수를 호출하게 되는 경우 스택 영역이 초과하면서 Stack Overflow(스택오버플로우)에러가 발생한다.
    
    **힙(Heap) 영역:**
    
    힙 영역은 관리가 가능한 데이터 이외의 다른 형태의 데이터를 관리하기 위한 공간(Free Space)이다.
    
    이 공간은 동적 메모리 할당 공간이므로 사용이 끝나면 운영체제가 쓸수 있도록 반납해야 한다. 프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리의 할당이 이루어지는 데이터 또는 스택과 같은 정적 메모리 할당과는 대조적이다.
    
    동적 메모리 할당은 어느 시점에 어느 정도의 공간을 할당할 수 있을지 정확히게 예측할 수 없으므로, 런타임에 확인가능하다.
    
- IPC
    
    프로세스가 다른 프로세스 자원에 접근하려면 IPC(Inter-Process Commnuication)를 사용해야 한다.
    IPC란 운영체제 상에서 실행 중인 프로세스 간에 정보를 주고받는 것을 말한다.
    
    프로세스는 자신에게 할당된 메모리 내의 정보만 접근할 수 있는데, 이는 안전성을 위해 운영체제에서 자기 프로세스의 메모리만 접근하도록 강제하고 있다는 것이다.
    IPC의 종류로는 파이프, 소켓, 공유메모리 등이 있다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33e9c891-6ffe-4340-bd67-8f6f921e83f7/Untitled.png)
    
    [https://dar0m.tistory.com/233](https://dar0m.tistory.com/233)
    

### **프로세스 제어 블록(Process Control Block, PCB)**

- 운영체제가 프로세스 관리를 위해 프로세스별 필요 정보들을 저장하는 공간이다.
- 프로세스가 생성될 때마다 고유의 PCB가 생성되고 프로세스가 완료되면 PCB는 제거된다.
- 프로세스가 CPU를 할당받아 처리되는 동안 프로세스 전환이 발생하면 작업 진행 내역을 PCB에 저장하고 CPU를 반환한다. 그리고 다시 CPU를 할당받으면 PCB를 불러와 작업을 재진행한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cef40ce1-803b-4e6c-9e2c-efcf16962761/Untitled.png)

**PCB 에 저장되는 정보**

1. 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
2. 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
3. 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
4. CPU 레지스터
5. CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
6. 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
7. 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
8. 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

### 프로세스의 5가지 상태

![https://user-images.githubusercontent.com/55946791/80938240-559b8600-8e13-11ea-9176-a121491a0fb3.jpg](https://user-images.githubusercontent.com/55946791/80938240-559b8600-8e13-11ea-9176-a121491a0fb3.jpg)

1. 생성 : 프로세스 생성 상태 , PCB를 할당받은 상태
2. 실행 : 프로세스가 CPU에 할당되어 실행 중인 상태
3. 준비 : 프로세스가 CPU에 할당되기를 기다리는 상태
4. 대기 : 보류(Block)라고도 하며, 프로세스가 입출력이나 이벤트릴 기다리는 상태
5. 종료 : 프로세스 종료 상태

### **스레드(Thread)**

- 스레드는 프로세스의 실행 단위라고 할 수 있다.
- 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
- 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지 Code/Data/Heap 형식으로 할당된 메모리 영역을 공유한다.
- 이러한 특징 때문에 어떤 스레드 하나에서 오류가 발생한다면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다.
- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ccc9fb8b-fb20-4a67-8ca2-a28432dccad8/Untitled.png)

### **스택을 스레드마다 독립적으로 할당하는 이유**

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다.

따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

### **PC Register 를 스레드마다 독립적으로 할당하는 이유**

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.

스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.

따라서 PC 레지스터를 독립적으로 할당한다.

### 자바 스레드(Java Thread) 란

- 일반 스레드와 거의 차이가 없으며, JVM이 운영체제의 역할을 한다.
- 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
- 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
- 아래와 같은 스레드와 관련된 많은 정보들도 JVM이 관리한다.
스레드가 몇 개 존재하는지,
스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지,
스레드의 상태는 무엇인지,
스레드 우선순위는 얼마인지,
- JVM은 main() 메소드를 찾아 Main Thread를 동작시킵니다. 기본적으로 Main Thread는 다른 쓰레드와 차별화 되어 있는게 아니라 처음에 수행되는 쓰레드입니다. 그러므로 메인 쓰레드의 종료와 다른 쓰레드의 종료는 관련없이 별개로 동작합니다. 메인 쓰레드가 종료되어도 다른 모든 쓰레드가 종료되어야 JVM의 동작이 멈춥니다.
