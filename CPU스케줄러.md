**프로세스 ?**

**프로세스**(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 **작업**(task)이라는 용어와 거의 같은 의미로 쓰인다. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다.

이런 프로세스들을 `Ready Queue` 에 넣어놓고 처리하는데, 이때 `Ready Queue` 에 속해있는 프로세스들중 누구에게 CPU 를 할당할지 정하는 것을 **CPU 스케줄링** 이라고 한다.

![스크린샷 2019-03-02 오후 5.49.52.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb246574-f530-436d-a559-f9e8a03bf5ce/스크린샷_2019-03-02_오후_5.49.52.png)

스케줄링은 다음과 같은 때에 일어난다.

1. Running → Waiting 상태 : ( ex. I/O 요청, 자식프로세스 종료 - wait() 요청을 통해 종료 )
2. Running → Terminate 상태 : ( ex. 부모프로세스의 종료 )
3. Running → Ready 상태 : ( ex. 인터럽트 발생 )
4. Waiting → Ready 상태 : ( ex. I/O 완료 )

## 비선점 (nonpreemptive) 스케줄링

- CPU를 사용중인 프로세스가 자율적으로 반납하도록 하는 방식

![스크린샷 2019-03-02 오후 8.41.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9ef7566a-a9e8-4b2d-b269-d1387ca2536e/스크린샷_2019-03-02_오후_8.41.22.png)

### **FCFS(First Come First Served)**

- 먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리.
- 일단 CPU 를 잡으면 CPU burst 가 완료될 때까지 CPU 를 반환하지 않는다. 할당되었던 CPU 가 반환될 때만 스케줄링이 이루어진다.
    
    
    **CPU burst?**
    
    CPU의 명령을 실행하는 것
    

**단점**

- **convoy effect** : 소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.
    
    → ***CPU burst 가 완료될 때까지는 다음 작업이 진행되지 않기 때문***
    

### **SJF(Shortest - Job - First)**

- 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
- **starvation** : 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케줄링은 극단적으로 **CPU 사용이 짧은 job 을 선호**한다. 그래서 사용 시간이 긴 프로세스는 거의 **영원히** CPU 를 할당 받을 수 없다.

---

## 선점 (preemptive) 스케줄링

- 낮은 우선순위를 가진 프로세스보다 높은 우선순위를 가진 프로세스가 CPU를 선점하는 방식
- OS가 스케줄링의 알고리즘에 따라 적당한 프로세스에게 CPU를 할당하고, 필요시에는 회수하는 방식
- 일반적으로 3, 4 번 시점에서 사용하지만, 상황에 따라 1, 2 에서도 스케줄링이 가능

![993815445C7AC10303.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eab98e20-2b92-411e-90fd-587319556682/993815445C7AC10303.png)

### **SRTF(Shortest Remaining Time First)**

- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.

**문제점**

- **starvation** : 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time 측정 불가

---

### **Priority Scheduling**

- 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링
- 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
- 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.

**단점**

- **starvation**
- **무기한 봉쇄(Indefinite blocking)** : 실행 준비는 되어있으나 CPU 를 사용 못하는 프로세스를 CPU 가 무기한 대기하는 상태

**아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주는 aging 정책으로 해결 가능**

---

### **Round Robin**

- 현대적인 CPU 스케줄링
- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 가짐
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
- **CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우**에 효율적
- 프로세스의 context 를 save 할 수 있기 때문에 가능

**장점**

- `Response time`이 빨라진다.
    
    → 각 프로세스들이 할당 시간 이상 기다리지 않는다
    
- 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가 → 공정한 스케줄링

하지만 설정한 `time quantum`이 너무 커지면 `FCFS`와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 그렇기 때문에 적당한 `time quantum`을 설정하는 것이 중요하다.

**overhead?**

어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 의미
