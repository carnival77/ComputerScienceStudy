## Bean Scope

> 스프링의 빈이 생성되고 적용되는 관리 범위 기본스코프는 싱글톤이다.
> 

### 스코프의 종류

1. 싱글톤 (singleton)
    - Spring 프레임워크에서 기본이 되는 스코프
    - 스프링 컨테이너의 시작과 종료까지 1개의 객체로 유지됨
        - 컨테이너가 사라지면 bean도 제거된다.
    - 생성된 하나의 인스턴스는 single beans cache에 저장되고, 해당 bean에 대한 요청과 참조가 있으면 캐시된 객체를 반환한다. (즉 하나만 생성해서 동일한 것을 참조한다.)
    - 기본적으로 모든 bean은 스코프가 명시적으로 지정되지 않을 경우 싱글톤이다.
    
    ![https://blog.kakaocdn.net/dn/trldf/btrcvxSpy63/OicN5uTWmxLCiS8Kn1jKpK/img.png](https://blog.kakaocdn.net/dn/trldf/btrcvxSpy63/OicN5uTWmxLCiS8Kn1jKpK/img.png)
    
2. 프로토 타입 (prototype) 
    - 빈을 컨테이너에 요청할 때마다 매번 새로운 오브젝트(bean) 생성
    - 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 스코프
    - 요청이 오면 항상 새로운 인스턴스를 생성하여 반환하고 이후에 관리하지 않는다
        - IoC 기본 원칙을 따르지 않는다. 프로토타입 스코프를 갖는 빈은 초기화와 DI까지는 해주지만 빈을 제공하고 나면 컨테이너는 더 이상 빈 오브젝트를 관리하지 않는다. DL이나 DI를 통해 빈 오브젝트를 주입받은 다른 빈이 컨테이너가 제공한 빈 오브젝트를 관리하게 된다.
            - 빈이 제거되기 전에 빈이 사용한 리소스를 정리하기 위해 호출하는 메소드를 이용할 수 없다.
            - 프로토타입 빈은 이 빈을 주입받은 오브젝트나 코드에 종속적이다.
    - 빈을 생성하고, DI하고, 초기화까지만 한 후 클라이언트에게 넘긴다.
        - 종료 메서드 호출이 안된다
        - 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.
    - 프로토타입 빈을 주입받은 빈이 싱글톤이라면, 이 빈에 주입된 프로토타입 빈도 역시 싱글톤 생명주기를 따른다.
    
    [https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FH8efQ%2Fbtrcus4VZml%2FkzBMqopdt1ucno64JTRZIk%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FH8efQ%2Fbtrcus4VZml%2FkzBMqopdt1ucno64JTRZIk%2Fimg.png)
    

웹 관련 스코프

1. request 
    - 하나의 Bean 정의에 대해서 하나의 HTTP request의 생명주기 안에 단하나의 객체만 존재한다. 즉 각각의 HTTP request는 자신만의 객체를 가진다.
    - 하나의 HTTP request가 life cycle
    - 각각의 요청이 들어오고 나갈때까지 유지되는 스코프
    - 각 요청별로 독립적인 빈이 만들어지기 때문에 빈 오브젝트에 상태값을 저장해도 된다.
    - 요청 스코프 빈의 주요 용도는 애플리케이션 코드에서 생성한 정보를 프레임워크 레벨의 서비스나 인터셉터 등에 전달하는 것이다.
    
    ![https://media.vlpt.us/images/neity16/post/d6ad6f32-f4d8-412f-a861-6b92cb521dd1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-02-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.05.39.png](https://media.vlpt.us/images/neity16/post/d6ad6f32-f4d8-412f-a861-6b92cb521dd1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-02-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.05.39.png)
    
2. session 
    - 세션이 생성되고 종료될 때 까지 유지되는 스코프
    - HTTP 세션과 같은 존재 범위를 갖는 빈으로 만들어주는 스코프다.
    - HTTP 세션은 사용자별로 만들어지고 브라우저를 닫거나 세션 타임이 종료될 때까지 유지되기 때문에 로그인 정보나 사용자별 선택옵션 등을 저장해두기에 유용하다. 하지만 세션을 직접 이용하는 건 매우 번거롭고, 웹 환경 정보에 접근할 수 있는 계층에서만 가능한 작업이다.
    - 세션 스코프를 이용하면 HTTP 세션에 저장되는 정보를 모든 계층에서 안전하게 이용할 수 있다.
3. application 
    - 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프
    - 웹 애플리케이션과 애플리케이션 컨텍스트의 존재 범위가 다른 경우가 있는 경우 사용한다.
    

**참고**

**싱글톤으로 적합한 객체**

1. 상태가 없는 공유 객체
    - 상태를 가지고 있지 않은 객체는 동기화 비용이 없다. 따라서 매번 이 객체를 참조하는 곳에서 새로운 객체를 생성할 이유가 없다.
2.  읽기용으로만 상태를 가진 공유 객체
    - 1번과 유사하게 상태를 가지고 있으나 읽기 전용이므로 여전히 동기화 비용이 들지 않는다. 매 요청마다 새로운 객체 생성할 필요가 없다.
3. 공유가 필요한 상태를 지닌 공유 객체
    - 객체 간의 반드시 공유해야 할 상태를 지닌 객체가 하나 있다면, 이 경우에는 해당 상태의 쓰기를 가능한 동기화 할 경우 싱글톤도 적합하다.
4. 쓰기가 가능한 상태를 지니면서도 사용빈도가 매우 높은 객체
    - 애플리케이션 안에서 정말로 사용빈도가 높다면, 쓰기 접근에 대한 동기화 비용을 감안하고서라도 싱글톤을 고려할만하다. 이 방법은 1. 장시간에 걸쳐 매우 많은 객체가 생성될 때, 2. 해당 객체가 매우 작은 양의 쓰기상태를 가지고 있을 때, 3. 객체 생성비용이 매우 클 때에 유용한 선택이 될 수 있다.

**비싱글톤으로 적합한 객체**
1. ****쓰기가 가능한 상태를 지닌 객체

- 쓰기가 가능한 상태가 많아서 동기화 비용이 객체 생성 비용보다 크다면 싱글톤으로 적합하지 않다.
1. 상태가 노출되지 않은 객체
    - 일부 제한적인 경우, 내부 상태를 외부에 노출하지 않는 빈을 참조하여 다른 의존객체와는 독립적으로 작업을 수행하는 의존 객체가 있다면 싱글톤보다 비싱글톤 객체를 사용하는 것이 더 나을 수 있다.
